战斗力（BP）计算：
HP/10 + SP/20 + ATK/2 + DEF/5 + SPD/2 + （6-灵根数量）*等级加值 + 技能加值

maxHP计算： 10+level * 4.75 * 境界加成 + 物品升级效果 + 木灵根加成，水灵根弱加成
maxSP计算： 5+level * 1.5 * 境界加成 + 物品升级效果 + 水灵根加成， 金灵根弱加成

ATK : 5 + 等级加成（每级+0.5，每10级*1.25） + 装备加成 + 火灵根加成, 木灵根弱加成
DEF : 5 + 等级加成（每级+0.5，每10级*1.25） + 装备加成 + 土灵根加成, 火灵根弱加成
SPD ：5 + 等级加成（每级+0.5，每10级*1.25） + 装备加成 + 金灵根加成, 土灵根弱加成

修炼经验获得： 随机 5-30 * (1+level/10) * 灵根加成

天灵根 2
单灵根 1.5
双灵根 1.25
三灵根 1
四灵根 0.8
杂灵根 0.6

        单灵根  双灵根  三灵根 四灵根 杂灵根
金 ATK +105%  | +50% | +30% | +20% | +10%
木 HP  +105%  | +50% | +30% | +20% | +10%
水 SP  +105%  | +50% | +30% | +20% | +10%
火 ATK +105%  | +50% | +30% | +20% | +10%
土 DEF +105%  | +50% | +30% | +20% | +10%

天灵根效果： 灵根加成*1.5
弱加成效果 = 灵根加成*0.3

//主动技，action是 SkillFun[n]里代入的function名。
//被动会计入平时的属性中。 主动不会计入平时属性，只有使用技能时才计入。所有主动技能都会消耗SP。 主动技能中，分 攻击、防御、特殊、治疗 四种技能。
//治疗技能平时也可以用。
//每日可以使用指令：.休养生息 来进行恢复HP、SP、AP。一天只能使用一次。 用了休养生息后，当天再也无法出门历练以及进行PK。

data.flag = {
	upgrade: object {}  属性提升记录
	breakbuff: boolean  突破提升，突破成功时清零。
	stats : str 当前状态。可叠加，在debuff中进行管理。
	debuff : object {}  各debuff的状态记录，包括处理方式。 回合结束时进行统一计算。
	canAct : boolean  能否做出反应。 战斗时统一判定。 石化，冰冻，迷幻，紧固状态都无法动弹。

}

    ctx.command('my-command')
		.option('writer', '-w <id>')
		.option('writer', '--anonymous', { value: 0 })
		.action(({ options }) => JSON.stringify(options))

    ctx.command('setrole <message> [target] [username]','管理指令。可以设置被艾特群员的权限。')
    .action(async ({ session },message, target, username) => {
		let level = {
			owner:5, admin:4, leader:3, high:2, member:1, banned: 0
		}
		let userdata
		let order = await ctx.database.getUser(session.platform, session.userId)

		if(session.userId !== '1794362968' || (session.userId !== '1794362968' && order.authority < 4) ){
			return '没有权限。'
		}
		else{
			const parsedTarget = target ? s.parse(target)[0] : null

			console.log(message,username,parsedTarget)

			if(parsedTarget){
				userdata = await ctx.database.getUser(session.platform, parsedTarget.data.id);

				console.log('\nbefore:',userdata);

				userdata['authority'] = level[message];
				if(username) userdata['name'] = username;
				if(!userdata.name) userdata['name'] = "";

				console.log('\nafter:',userdata);

				await ctx.database.setUser(session.platform, parsedTarget.data.id, userdata);

				userdata = await ctx.database.getUser(session.platform, parsedTarget.data.id);
			}
			else{
				userdata = order;
				userdata['authority'] = level[message];
				if(username) userdata['name'] = username;
				if(!userdata.name) userdata['name'] = "";

				await ctx.database.setUser(session.platform, session.userId, userdata)
				userdata = await ctx.database.getUser(session.platform, session.userId);
			}
		
			return JSON.stringify(userdata)			
		}     
    })

    ctx.command('checkdata <message>','debug指令，可以在控制台看到指定类型的数据。')
    .action(async ({ session }, message) => {
		 const data = await ctx.database.get(message,null)
		 console.log(data);
		 return 'please check in the log.'
    })

    ctx.command('editdata <message>', 'debug')
		.action(async ({ session }, message) => {

				let stats = await ctx.database.stats()
				console.log(stats)
				if ( !stats.tables?.keywords ){
						ctx.model.extend("keywords",{
						id:"unsigned",
						name:"string",
						group:"list"
				},{
						autoInc: true
				})
				}
				let data = await ctx.database.get('keywords', { id: 1 })
				console.log(data)

				let data = await ctx.database.get('keywords',{name:'送礼'})
				console.log(data)
				data[0].group.push('送礼')
				await ctx.database.set('keywords', {name:'送礼'} , { group: data[0].group })

				let newdata = await ctx.database.get('keywords', {name:'送礼'})
				console.log(newdata)
		})

    /*ctx.command('cleardata <message>')
    .action(async ({ session },message)=>{
		ctx.database.remove(message,null)
		let data = await ctx.database.get(message,null)
		console.log(data)
		return 'all data is cleared, please check in the log.'
    })
*/

//普通攻击
export function NormalAtk(player, target){
    let dmg = player.ATK
    let def = target.DEF
    let spd = player.SPD
    let goal = target.SPD

    //先看命中，主动方具备命中优势。
    //双方骰点。 攻击方 1+等级/10 D 速度/2，  防守方 1+等级/10 D 速度/2
    //优势方 追加 一个 1d 速度/10（保底10）
    let a, b, aroll, broll, croll, crit, at,bt

    at = Math.max(Math.floor(1+player.level/10+0.5),2)
    bt = Math.max(Math.floor(1+target.level/10+0.5),2)

    aroll = Roll(Math.floor(spd/5),6)
    broll = Roll(Math.floor(goal/5),5)
    croll = Roll(at,Math.max(spd/at,6));

    console.log('攻击方速度：',spd, '防守方速度：',goal)
    console.log('攻击方命中骰点：',aroll.result, '大成功次数',aroll.bonus, '优势骰点',croll.result)  
    console.log('防守方闪避骰点：',broll.result, '大成功次数',broll.bonus,)

    a = aroll.result + croll.result + spd + ( aroll.bonus > spd/25 ? aroll.bonus*6 : 0)
    b = aroll.result + goal*0.8 + ( aroll.bonus > spd/25 ? aroll.bonus*5 : 0)

    console.log('最终结果： 攻：', a,'守：', b, ( a >= b ? '命中' : '攻击失败' ))

    if( a >= b ){
        at = Math.max(Math.floor(dmg/5+0.5),2)
        bt = Math.max(Math.floor(def/5+0.5),2)

        aroll = Roll(at, 6)
        broll = Roll(bt, 5)
        if(aroll.bonus >= at/5 ) crit = 10*aroll.bonus + dmg/2

        console.log('攻击方攻击力：',dmg, '防守方防御力：',def)
        console.log('攻击方伤害骰点：',aroll.result, '大成功次数',aroll.bonus, ( crit ? '会心伤害'+crit : '' ))  
        console.log('防守方防御骰点：',broll.result, '大成功次数',broll.bonus, '防御效率', def/dmg)
        a = aroll.result + dmg
        b = aroll.result + def/2
        console.log('最终结果造成伤害：', Math.max(a-b,Math.max(def/20,1)) + ( crit ? Math.max(crit-b/5,5) : 0))        
    }
    //返回伤害值与会心伤害。
    let result = {
        dmg: Math.max(a-b,1),
        crit: ( crit ? Math.max(crit-b/2,5) : 0),
    }
    return result
}