{
  "version": 3,
  "sources": ["../../node_modules/cosmokit/src/misc.ts", "../../node_modules/cosmokit/src/array.ts", "../../node_modules/cosmokit/src/string.ts", "../../node_modules/cosmokit/src/time.ts", "../../node_modules/schemastery/src/index.ts"],
  "sourcesContent": ["export type Dict<T = any, K extends string = string> = { [key in K]?: T }\nexport type Get<T extends {}, K> = K extends keyof T ? T[K] : never\nexport type Extract<S, T, U = S> = S extends T ? U : never\nexport type MaybeArray<T> = [T] extends [unknown[]] ? T : T | T[]\nexport type Promisify<T> = Promise<T extends Promise<infer S> ? S : T>\nexport type Awaitable<T> = [T] extends [Promise<unknown>] ? T : T | Promise<T>\nexport type Intersect<U> = (U extends any ? (arg: U) => void : never) extends ((arg: infer I) => void) ? I : never\n\nexport function noop(): any {}\n\nexport function isNullable(value: any) {\n  return value === null || value === undefined\n}\n\nexport function isPlainObject(data: any) {\n  return data && typeof data === 'object' && !Array.isArray(data)\n}\n\nexport function valueMap<T, U>(object: Dict<T>, transform: (value: T, key: string) => U): Dict<U> {\n  return Object.fromEntries(Object.entries(object).map(([key, value]) => [key, transform(value, key)]))\n}\n\nexport function clone<T>(source: T): T\nexport function clone(source: any) {\n  if (!source || typeof source !== 'object') return source\n  if (Array.isArray(source)) return source.map(clone)\n  if (source instanceof Date) return new Date(source.valueOf())\n  if (source instanceof RegExp) return new RegExp(source.source, source.flags)\n  return valueMap(source, clone)\n}\n\nexport function pick<T, K extends keyof T>(source: T, keys?: Iterable<K>, forced?: boolean) {\n  if (!keys) return { ...source }\n  const result = {} as Pick<T, K>\n  for (const key of keys) {\n    if (forced || key in source) result[key] = source[key]\n  }\n  return result\n}\n\nexport function omit<T, K extends keyof T>(source: T, keys?: Iterable<K>) {\n  if (!keys) return { ...source }\n  const result = { ...source } as Omit<T, K>\n  for (const key of keys) {\n    Reflect.deleteProperty(result, key)\n  }\n  return result\n}\n\nexport function defineProperty<T, K extends keyof T>(object: T, key: K, value: T[K]): void\nexport function defineProperty<T, K extends keyof any>(object: T, key: K, value: any): void\nexport function defineProperty<T, K extends keyof any>(object: T, key: K, value: any) {\n  Object.defineProperty(object, key, { writable: true, value })\n}\n", "import { isNullable } from './misc'\n\nexport function contain(array1: readonly any[], array2: readonly any[]) {\n  return array2.every(item => array1.includes(item))\n}\n\nexport function intersection<T>(array1: readonly T[], array2: readonly T[]) {\n  return array1.filter(item => array2.includes(item))\n}\n\nexport function difference<S>(array1: readonly S[], array2: readonly any[]) {\n  return array1.filter(item => !array2.includes(item))\n}\n\nexport function union<T>(array1: readonly T[], array2: readonly T[]) {\n  return Array.from(new Set([...array1, ...array2]))\n}\n\nexport function deduplicate<T>(array: readonly T[]) {\n  return [...new Set(array)]\n}\n\nexport function remove<T>(list: T[], item: T) {\n  const index = list.indexOf(item)\n  if (index >= 0) {\n    list.splice(index, 1)\n    return true\n  }\n}\n\nexport function makeArray<T>(source: T | T[]) {\n  return Array.isArray(source) ? source : isNullable(source) ? [] : [source]\n}\n", "export function capitalize(source: string) {\n  return source.charAt(0).toUpperCase() + source.slice(1)\n}\n\nexport function uncapitalize(source: string) {\n  return source.charAt(0).toLowerCase() + source.slice(1)\n}\n\nexport function camelCase(source: string) {\n  return source.replace(/[_-][a-z]/g, str => str.slice(1).toUpperCase())\n}\n\nexport function paramCase(source: string) {\n  return uncapitalize(source).replace(/_/g, '-').replace(/(?<!^)[A-Z]/g, str => '-' + str.toLowerCase())\n}\n\nexport function snakeCase(source: string) {\n  return uncapitalize(source).replace(/-/g, '_').replace(/(?<!^)[A-Z]/g, str => '_' + str.toLowerCase())\n}\n\nexport const camelize = camelCase\nexport const hyphenate = paramCase\n\nnamespace Letter {\n  /* eslint-disable @typescript-eslint/member-delimiter-style */\n  interface LowerToUpper {\n    a: 'A', b: 'B', c: 'C', d: 'D', e: 'E', f: 'F', g: 'G', h: 'H', i: 'I', j: 'J', k: 'K', l: 'L', m: 'M',\n    n: 'N', o: 'O', p: 'P', q: 'Q', r: 'R', s: 'S', t: 'T', u: 'U', v: 'V', w: 'W', x: 'X', y: 'Y', z: 'Z',\n  }\n\n  interface UpperToLower {\n    A: 'a', B: 'b', C: 'c', D: 'd', E: 'e', F: 'f', G: 'g', H: 'h', I: 'i', J: 'j', K: 'k', L: 'l', M: 'm',\n    N: 'n', O: 'o', P: 'p', Q: 'q', R: 'r', S: 's', T: 't', U: 'u', V: 'v', W: 'w', X: 'x', Y: 'y', Z: 'z',\n  }\n  /* eslint-enable @typescript-eslint/member-delimiter-style */\n\n  export type Upper = keyof UpperToLower\n  export type Lower = keyof LowerToUpper\n\n  export type ToUpper<S extends string> = S extends Lower ? LowerToUpper[S] : S\n  export type ToLower<S extends string, P extends string = ''> = S extends Upper ? `${P}${UpperToLower[S]}` : S\n}\n\n/* eslint-disable @typescript-eslint/naming-convention */\nexport type camelize<S extends string> = S extends `${infer L}-${infer M}${infer R}` ? `${L}${Letter.ToUpper<M>}${camelize<R>}` : S\nexport type hyphenate<S extends string> = S extends `${infer L}${infer R}` ? `${Letter.ToLower<L, '-'>}${hyphenate<R>}` : S\n/* eslint-enable @typescript-eslint/naming-convention */\n\nexport function trimSlash(source: string) {\n  return source.replace(/\\/$/, '')\n}\n\nexport function sanitize(source: string) {\n  if (!source.startsWith('/')) source = '/' + source\n  return trimSlash(source)\n}\n", "export namespace Time {\n  export const millisecond = 1\n  export const second = 1000\n  export const minute = second * 60\n  export const hour = minute * 60\n  export const day = hour * 24\n  export const week = day * 7\n\n  let timezoneOffset = new Date().getTimezoneOffset()\n\n  export function setTimezoneOffset(offset: number) {\n    timezoneOffset = offset\n  }\n\n  export function getTimezoneOffset() {\n    return timezoneOffset\n  }\n\n  export function getDateNumber(date: number | Date = new Date(), offset?: number) {\n    if (typeof date === 'number') date = new Date(date)\n    if (offset === undefined) offset = timezoneOffset\n    return Math.floor((date.valueOf() / minute - offset) / 1440)\n  }\n\n  export function fromDateNumber(value: number, offset?: number) {\n    const date = new Date(value * day)\n    if (offset === undefined) offset = timezoneOffset\n    return new Date(+date + offset * minute)\n  }\n\n  const numeric = /\\d+(?:\\.\\d+)?/.source\n  const timeRegExp = new RegExp(`^${[\n    'w(?:eek(?:s)?)?',\n    'd(?:ay(?:s)?)?',\n    'h(?:our(?:s)?)?',\n    'm(?:in(?:ute)?(?:s)?)?',\n    's(?:ec(?:ond)?(?:s)?)?',\n  ].map(unit => `(${numeric}${unit})?`).join('')}$`)\n\n  export function parseTime(source: string) {\n    const capture = timeRegExp.exec(source)\n    if (!capture) return 0\n    return (parseFloat(capture[1]) * week || 0)\n      + (parseFloat(capture[2]) * day || 0)\n      + (parseFloat(capture[3]) * hour || 0)\n      + (parseFloat(capture[4]) * minute || 0)\n      + (parseFloat(capture[5]) * second || 0)\n  }\n\n  export function parseDate(date: string) {\n    const parsed = parseTime(date)\n    if (parsed) {\n      date = Date.now() + parsed as any\n    } else if (/^\\d{1,2}(:\\d{1,2}){1,2}$/.test(date)) {\n      date = `${new Date().toLocaleDateString()}-${date}`\n    } else if (/^\\d{1,2}-\\d{1,2}-\\d{1,2}(:\\d{1,2}){1,2}$/.test(date)) {\n      date = `${new Date().getFullYear()}-${date}`\n    }\n    return date ? new Date(date) : new Date()\n  }\n\n  export function format(ms: number) {\n    const abs = Math.abs(ms)\n    if (abs >= day - hour / 2) {\n      return Math.round(ms / day) + 'd'\n    } else if (abs >= hour - minute / 2) {\n      return Math.round(ms / hour) + 'h'\n    } else if (abs >= minute - second / 2) {\n      return Math.round(ms / minute) + 'm'\n    } else if (abs >= second) {\n      return Math.round(ms / second) + 's'\n    }\n    return ms + 'ms'\n  }\n\n  export function toDigits(source: number, length = 2) {\n    return source.toString().padStart(length, '0')\n  }\n\n  export function template(template: string, time = new Date()) {\n    return template\n      .replace('yyyy', time.getFullYear().toString())\n      .replace('yy', time.getFullYear().toString().slice(2))\n      .replace('MM', toDigits(time.getMonth() + 1))\n      .replace('dd', toDigits(time.getDate()))\n      .replace('hh', toDigits(time.getHours()))\n      .replace('mm', toDigits(time.getMinutes()))\n      .replace('ss', toDigits(time.getSeconds()))\n      .replace('SSS', toDigits(time.getMilliseconds(), 3))\n  }\n}\n", "import { clone, Dict, Intersect, isNullable, isPlainObject, valueMap } from 'cosmokit'\n\ninterface Schema<S = any, T = S> extends Schema.Base<T> {\n  (data?: S): T\n  new (data?: S): T\n  [kSchema]: true\n  toJSON(): Schema.Base<T>\n  required(value?: boolean): Schema<S, T>\n  hidden(value?: boolean): Schema<S, T>\n  role(text: string): Schema<S, T>\n  link(link: string): Schema<S, T>\n  default(value: T): Schema<S, T>\n  comment(text: string): Schema<S, T>\n  description(text: string): Schema<S, T>\n  max(value: number): Schema<S, T>\n  min(value: number): Schema<S, T>\n  step(value: number): Schema<S, T>\n  set(key: string, value: Schema): Schema<S, T>\n  push(value: Schema): Schema<S, T>\n}\n\nnamespace Schema {\n  export type From<T> =\n    | T extends string | number | boolean ? Schema<T>\n    : T extends Schema ? T\n    : T extends typeof String ? Schema<string>\n    : T extends typeof Number ? Schema<number>\n    : T extends typeof Boolean ? Schema<boolean>\n    : T extends typeof Function ? Schema<Function, (...args: any[]) => any>\n    : T extends Constructor<infer S> ? Schema<S>\n    : never\n\n  type _TypeS<X> = X extends Schema<infer S, unknown> ? S : never\n  type _TypeT<X> = ReturnType<Extract<X, Schema>>\n\n  export type TypeS<X> = _TypeS<From<X>>\n  export type TypeT<X> = _TypeT<From<X>>\n  export type Resolve = (data: any, schema?: Schema, strict?: boolean) => [any, any?]\n\n  export interface Base<T = any> {\n    uid?: number\n    type?: string\n    sKey?: Schema\n    inner?: Schema\n    list?: Schema[]\n    dict?: Dict<Schema>\n    bits?: Dict<number>\n    callback?: Function\n    value?: T\n    meta?: Meta<T>\n    refs?: Dict<Schema>\n    toString(inline?: boolean): string\n  }\n\n  export interface Meta<T = any> {\n    default?: T extends {} ? Partial<T> : T\n    required?: boolean\n    hidden?: boolean\n    role?: string\n    link?: string\n    description?: string\n    comment?: string\n    max?: number\n    min?: number\n    step?: number\n  }\n\n  type TupleS<X extends readonly any[]> = X extends readonly [infer L, ...infer R] ? [TypeS<L>?, ...TupleS<R>] : any[]\n  type TupleT<X extends readonly any[]> = X extends readonly [infer L, ...infer R] ? [TypeT<L>?, ...TupleT<R>] : any[]\n  type ObjectS<X extends Dict> = { [K in keyof X]?: TypeS<X[K]> } & Dict\n  type ObjectT<X extends Dict> = { [K in keyof X]: TypeT<X[K]> } & Dict\n  type Constructor<T = any> = new (...args: any[]) => T\n\n  export interface Static {\n    <T = any>(options: Base<T>): Schema<T>\n    new <T = any>(options: Base<T>): Schema<T>\n    prototype: Schema\n    resolve: Resolve\n    from<T = any>(source?: T): Schema<From<T>>\n    extend(type: string, resolve: Resolve): void\n    any(): Schema<any>\n    never(): Schema<never>\n    const<T>(value: T): Schema<T>\n    string(): Schema<string>\n    number(): Schema<number>\n    natural(): Schema<number>\n    percent(): Schema<number>\n    boolean(): Schema<boolean>\n    date(): Schema<string | Date, Date>\n    bitset<K extends string>(bits: Dict<number, K>): Schema<number | readonly K[], number>\n    function(): Schema<Function, (...args: any[]) => any>\n    is<T>(constructor: Constructor<T>): Schema<T>\n    array<X>(inner: X): Schema<TypeS<X>[], TypeT<X>[]>\n    dict<X, Y extends Schema<any, string> = Schema<string>>(inner: X, sKey?: Y): Schema<Dict<TypeS<X>, TypeS<Y>>, Dict<TypeT<X>, TypeT<Y>>>\n    tuple<X extends readonly any[]>(list: X): Schema<TupleS<X>, TupleT<X>>\n    object<X extends Dict>(dict: X): Schema<ObjectS<X>, ObjectT<X>>\n    union<X>(list: readonly X[]): Schema<TypeS<X>, TypeT<X>>\n    intersect<X>(list: readonly X[]): Schema<Intersect<TypeS<X>>, Intersect<TypeT<X>>>\n    transform<X, T>(inner: X, callback: (value: TypeS<X>) => T): Schema<TypeS<X>, T>\n  }\n}\n\nlet index = 0\n\nconst kSchema = Symbol.for('schemastery')\n\nconst Schema = function (options: Schema.Base) {\n  const schema = function (data: any) {\n    return Schema.resolve(data, schema)[0]\n  } as Schema\n\n  if (options.refs) {\n    const refs = valueMap(options.refs, options => new Schema(options))\n    const getRef = (uid: any) => refs[uid]\n    for (const key in refs) {\n      const options = refs[key]\n      options.sKey = getRef(options.sKey)\n      options.inner = getRef(options.inner)\n      options.list = options.list && options.list.map(getRef)\n      options.dict = options.dict && valueMap(options.dict, getRef)\n    }\n    return refs[options.uid]\n  }\n\n  Object.assign(schema, options)\n  Object.defineProperty(schema, 'uid', { value: index++ })\n  Object.setPrototypeOf(schema, Schema.prototype)\n  schema.meta ||= {}\n  return schema\n} as Schema.Static\n\nSchema.prototype = Object.create(Function.prototype)\n\nSchema.prototype[kSchema] = true\n\nlet refs: Dict<Schema>\n\nSchema.prototype.toJSON = function toJSON() {\n  if (refs) {\n    refs[this.uid] ??= JSON.parse(JSON.stringify({ ...this }))\n    return this.uid\n  }\n\n  refs = { [this.uid]: { ...this } }\n  refs[this.uid] = JSON.parse(JSON.stringify({ ...this }))\n  const result = { uid: this.uid, refs }\n  refs = null\n  return result\n}\n\nSchema.prototype.set = function set(key, value) {\n  this.dict[key] = value\n  return this\n}\n\nSchema.prototype.push = function push(value) {\n  this.list.push(value)\n  return this\n}\n\nfor (const key of ['required', 'hidden']) {\n  Object.assign(Schema.prototype, {\n    [key](value = true) {\n      const schema = Schema(this)\n      schema.meta = { ...schema.meta, [key]: value }\n      return schema\n    },\n  })\n}\n\nfor (const key of ['default', 'role', 'link', 'comment', 'description', 'max', 'min', 'step']) {\n  Object.assign(Schema.prototype, {\n    [key](value: any) {\n      const schema = Schema(this)\n      schema.meta = { ...schema.meta, [key]: value }\n      return schema\n    },\n  })\n}\n\nconst resolvers: Dict<Schema.Resolve> = {}\n\nSchema.extend = function extend(type: string, resolve) {\n  resolvers[type] = resolve\n}\n\nSchema.resolve = function resolve(data, schema, strict) {\n  if (!schema) return [data]\n\n  if (isNullable(data)) {\n    if (schema.meta.required) throw new TypeError(`missing required value`)\n    const fallback = schema.meta.default\n    if (isNullable(fallback)) return [data]\n    data = clone(fallback)\n  }\n\n  const callback = resolvers[schema.type]\n  if (callback) return callback(data, schema, strict)\n  throw new TypeError(`unsupported type \"${schema.type}\"`)\n}\n\nSchema.from = function from(source: any) {\n  if (isNullable(source)) {\n    return Schema.any()\n  } else if (['string', 'number', 'boolean'].includes(typeof source)) {\n    return Schema.const(source).required()\n  } else if (source[kSchema]) {\n    return source\n  } else if (typeof source === 'function') {\n    switch (source) {\n      case String: return Schema.string().required()\n      case Number: return Schema.number().required()\n      case Boolean: return Schema.boolean().required()\n      case Function: return Schema.function().required()\n      default: return Schema.is(source).required()\n    }\n  } else {\n    throw new TypeError(`cannot infer schema from ${source}`)\n  }\n}\n\nSchema.natural = function natural() {\n  return Schema.number().step(1).min(0)\n}\n\nSchema.percent = function percent() {\n  return Schema.number().step(0.01).min(0).max(1).role('slider')\n}\n\nSchema.date = () => Schema.union([\n  Schema.is(Date),\n  Schema.transform(Schema.string().role('datetime'), (value) => {\n    const date = new Date(value)\n    if (isNaN(+date)) throw new TypeError(`invalid date \"${value}\"`)\n    return date\n  }),\n])\n\nSchema.extend('any', (data) => {\n  return [data]\n})\n\nSchema.extend('never', (data) => {\n  throw new TypeError(`expected nullable but got ${data}`)\n})\n\nSchema.extend('const', (data, { value }) => {\n  if (data === value) return [value]\n  throw new TypeError(`expected ${value} but got ${data}`)\n})\n\nfunction checkWithinRange(data: number, meta: Schema.Meta<any>, description: string) {\n  const { max = Infinity, min = -Infinity } = meta\n  if (data > max) throw new TypeError(`expected ${description} <= ${max} but got ${data}`)\n  if (data < min) throw new TypeError(`expected ${description} >= ${min} but got ${data}`)\n}\n\nSchema.extend('string', (data, { meta }) => {\n  if (typeof data !== 'string') throw new TypeError(`expected string but got ${data}`)\n  checkWithinRange(data.length, meta, 'string length')\n  return [data]\n})\n\nSchema.extend('number', (data, { meta }) => {\n  if (typeof data !== 'number') throw new TypeError(`expected number but got ${data}`)\n  checkWithinRange(data, meta, 'number')\n  const { step } = meta\n  if (step) {\n    const quotient = Math.abs(data - (meta.min ?? 0)) % step\n    if (quotient >= Number.EPSILON && quotient < step - Number.EPSILON) {\n      throw new TypeError(`expected number multiple of ${step} but got ${data}`)\n    }\n  }\n  return [data]\n})\n\nSchema.extend('boolean', (data) => {\n  if (typeof data === 'boolean') return [data]\n  throw new TypeError(`expected boolean but got ${data}`)\n})\n\nSchema.extend('bitset', (data, { bits }) => {\n  if (typeof data === 'number') return [data]\n  if (!Array.isArray(data)) throw new TypeError(`expected array but got ${data}`)\n  let result = 0\n  for (const value of data) {\n    if (typeof value !== 'string') throw new TypeError(`expected string but got ${value}`)\n    if (!(value in bits)) throw new TypeError(`unknown value ${value}`)\n    result |= bits[value]\n  }\n  return [result, result]\n})\n\nSchema.extend('function', (data) => {\n  if (typeof data === 'function') return [data]\n  throw new TypeError(`expected function but got ${data}`)\n})\n\nSchema.extend('is', (data, { callback }) => {\n  if (data instanceof callback) return [data]\n  throw new TypeError(`expected ${callback.name} but got ${data}`)\n})\n\nfunction property(data: any, key: keyof any, schema?: Schema) {\n  const [value, adapted] = Schema.resolve(data[key], schema)\n  if (!isNullable(adapted)) data[key] = adapted\n  return value\n}\n\nSchema.extend('array', (data, { inner, meta }) => {\n  if (!Array.isArray(data)) throw new TypeError(`expected array but got ${data}`)\n  checkWithinRange(data.length, meta, 'array length')\n  return [data.map((_, index) => property(data, index, inner))]\n})\n\nSchema.extend('dict', (data, { inner, sKey }, strict) => {\n  if (!isPlainObject(data)) throw new TypeError(`expected object but got ${data}`)\n  const result = {}\n  for (const key in data) {\n    let rKey: string\n    try {\n      rKey = Schema.resolve(key, sKey)[0]\n    } catch (error) {\n      if (strict) continue\n      throw error\n    }\n    result[rKey] = property(data, key, inner)\n    data[rKey] = data[key]\n    if (key !== rKey) delete data[key]\n  }\n  return [result]\n})\n\nSchema.extend('tuple', (data, { list }, strict) => {\n  if (!Array.isArray(data)) throw new TypeError(`expected array but got ${data}`)\n  const result = list.map((inner, index) => property(data, index, inner))\n  if (strict) return [result]\n  result.push(...data.slice(list.length))\n  return [result]\n})\n\nfunction merge(result: any, data: any) {\n  for (const key in data) {\n    if (key in result) continue\n    result[key] = data[key]\n  }\n}\n\nSchema.extend('object', (data, { dict }, strict) => {\n  if (!isPlainObject(data)) throw new TypeError(`expected object but got ${data}`)\n  const result = {}\n  for (const key in dict) {\n    const value = property(data, key, dict[key])\n    if (!isNullable(value) || key in data) {\n      result[key] = value\n    }\n  }\n  if (!strict) merge(result, data)\n  return [result]\n})\n\nSchema.extend('union', (data, { list, toString }) => {\n  const messages: string[] = []\n  for (const inner of list) {\n    try {\n      return Schema.resolve(data, inner)\n    } catch (error) {\n      messages.push(error.message)\n    }\n  }\n  throw new TypeError(`expected ${toString()} but got ${JSON.stringify(data)}`)\n})\n\nSchema.extend('intersect', (data, { list }, strict) => {\n  const result = {}\n  for (const inner of list) {\n    const value = Schema.resolve(data, inner, true)[0]\n    Object.assign(result, value)\n  }\n  if (!strict && isPlainObject(data)) merge(result, data)\n  return [result]\n})\n\nSchema.extend('transform', (data, { inner, callback }) => {\n  const [result, adapted = data] = Schema.resolve(data, inner, true)\n  if (isPlainObject(data)) {\n    const temp = {}\n    for (const key in result) {\n      if (!(key in data)) continue\n      temp[key] = data[key]\n      delete data[key]\n    }\n    Object.assign(data, callback(temp))\n    return [callback(result)]\n  } else {\n    return [callback(result), callback(adapted)]\n  }\n})\n\ntype Formatter = (schema: Schema, inline?: boolean) => string\n\nfunction defineMethod(name: string, keys: (keyof Schema.Base)[], format: Formatter) {\n  Object.assign(Schema, {\n    [name](...args: any[]) {\n      const schema = new Schema({ type: name })\n      schema.toString = format.bind(null, schema)\n      keys.forEach((key: string, index) => {\n        switch (key) {\n          case 'sKey': schema.sKey = args[index] ?? Schema.string(); break\n          case 'inner': schema.inner = Schema.from(args[index]); break\n          case 'list': schema.list = args[index].map(Schema.from); break\n          case 'dict': schema.dict = valueMap(args[index], Schema.from); break\n          case 'bits': {\n            schema.bits = {}\n            for (const key in args[index]) {\n              if (typeof args[index][key] !== 'number') continue\n              schema.bits[key] = args[index][key]\n            }\n            break\n          }\n          default: schema[key] = args[index]\n        }\n      })\n      if (name === 'object' || name === 'dict') {\n        schema.meta.default = {}\n      } else if (name === 'array' || name === 'tuple') {\n        schema.meta.default = []\n      } else if (name === 'bitset') {\n        schema.meta.default = 0\n      }\n      return schema\n    },\n  })\n}\n\ndefineMethod('is', ['callback'], ({ callback }) => callback.name)\ndefineMethod('any', [], () => 'any')\ndefineMethod('never', [], () => 'never')\ndefineMethod('const', ['value'], ({ value }) => typeof value === 'string' ? JSON.stringify(value) : value)\ndefineMethod('string', [], () => 'string')\ndefineMethod('number', [], () => 'number')\ndefineMethod('boolean', [], () => 'boolean')\ndefineMethod('bitset', ['bits'], () => 'bitset')\ndefineMethod('function', [], () => 'function')\ndefineMethod('array', ['inner'], ({ inner }) => `${inner.toString(true)}[]`)\ndefineMethod('dict', ['inner', 'sKey'], ({ inner, sKey }) => `{ [key: ${sKey.toString()}]: ${inner.toString()} }`)\ndefineMethod('tuple', ['list'], ({ list }) => `[${list.map((inner) => inner.toString()).join(', ')}]`)\n\ndefineMethod('object', ['dict'], ({ dict }) => {\n  if (Object.keys(dict).length === 0) return '{}'\n  return `{ ${Object.entries(dict).map(([key, inner]) => {\n    return `${key}${inner.meta.required ? '' : '?'}: ${inner.toString()}`\n  }).join(', ')} }`\n})\n\ndefineMethod('union', ['list'], ({ list }, inline) => {\n  const result = list.map(({ toString: format }) => format()).join(' | ')\n  return inline ? `(${result})` : result\n})\n\ndefineMethod('intersect', ['list'], ({ list }) => {\n  return `${list.map((inner) => inner.toString(true)).join(' & ')}`\n})\n\ndefineMethod('transform', ['inner', 'callback'], ({ inner }, isInner) => inner.toString(isInner))\n\nexport = Schema\n"],
  "mappings": "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",
  "names": ["refs", "options", "index", "key"]
}
